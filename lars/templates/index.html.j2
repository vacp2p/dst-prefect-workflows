{% extends "base.html.j2" %}

{% block title %}LARS - Lab Automated Resource Scheduler{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <h1 class="text-3xl font-bold mb-8">LARS Dashboard</h1>

    <!-- Mock Submission Form -->
    <div class="bg-gray-800 dark:bg-gray-800 shadow-lg rounded-lg p-6 mb-8">
        <h2 class="text-xl font-semibold mb-4 text-white">Submit Mock Simulations</h2>
        <div class="flex flex-wrap items-end gap-4">
            <div>
                <label for="count" class="block text-sm font-medium text-gray-300 mb-2">Number to Add:</label>
                <div class="relative rounded-md shadow-sm">
                    <input type="number" name="count" id="count" min="1" max="10" value="5" class="bg-gray-700 text-white focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 rounded-md">
                    <div class="absolute inset-y-0 right-0 flex items-center">
                        <button id="increment" class="h-full px-3 text-gray-300 hover:text-white">+</button>
                        <button id="decrement" class="h-full px-3 text-gray-300 hover:text-white">-</button>
                    </div>
                </div>
            </div>
            <div>
                <label for="baseNodes" class="block text-sm font-medium text-gray-300 mb-2">Base Nodes:</label>
                <div class="relative rounded-md shadow-sm">
                    <input type="number" name="baseNodes" id="baseNodes" min="1" max="1000" value="100" class="bg-gray-700 text-white focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 rounded-md">
                    <div class="absolute inset-y-0 right-0 flex items-center">
                        <button id="incrementNodes" class="h-full px-3 text-gray-300 hover:text-white">+</button>
                        <button id="decrementNodes" class="h-full px-3 text-gray-300 hover:text-white">-</button>
                    </div>
                </div>
            </div>
            <button id="submit-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2.5 px-8 rounded-md transition-colors">
                Submit
            </button>
        </div>
    </div>

    <!-- Main Dashboard Grid -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
        <!-- Queued Simulations -->
        <div class="md:col-span-1">
            <h2 class="text-xl font-semibold mb-4">Queued Simulations</h2>
            <div id="queue-container" class="space-y-4">
                <!-- Queue items will be added dynamically here -->
            </div>
        </div>

        <!-- Active Simulations -->
        <div class="md:col-span-1">
            <h2 class="text-xl font-semibold mb-4">Active Simulations</h2>
            <div id="active-container" class="space-y-4">
                <!-- Active items will be added dynamically here -->
            </div>
        </div>

        <!-- Last Finished Simulation -->
        <div class="md:col-span-1">
            <h2 class="text-xl font-semibold mb-4">Last Finished Simulation</h2>
            <div id="last-finished-container">
                <div id="no-finished" class="bg-gray-800 dark:bg-gray-800 shadow-lg rounded-lg p-4 text-gray-300">
                    No simulations completed yet.
                </div>
                <!-- Last finished simulation will be added dynamically here -->
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // DOM elements
    const queueContainer = document.getElementById('queue-container');
    const activeContainer = document.getElementById('active-container');
    const lastFinishedContainer = document.getElementById('last-finished-container');
    const noFinishedElement = document.getElementById('no-finished');
    const countInput = document.getElementById('count');
    const baseNodesInput = document.getElementById('baseNodes');
    const submitButton = document.getElementById('submit-button');
    const incrementButton = document.getElementById('increment');
    const decrementButton = document.getElementById('decrement');
    const incrementNodesButton = document.getElementById('incrementNodes');
    const decrementNodesButton = document.getElementById('decrementNodes');
    const cpuProgress = document.getElementById('cpu-progress');
    const memoryProgress = document.getElementById('memory-progress');
    const cpuText = document.getElementById('cpu-text');
    const memoryText = document.getElementById('memory-text');

    // Number input handlers
    incrementButton.addEventListener('click', () => {
        const current = parseInt(countInput.value, 10);
        countInput.value = Math.min(current + 1, 10);
    });

    decrementButton.addEventListener('click', () => {
        const current = parseInt(countInput.value, 10);
        countInput.value = Math.max(current - 1, 1);
    });

    incrementNodesButton.addEventListener('click', () => {
        const current = parseInt(baseNodesInput.value, 10);
        baseNodesInput.value = Math.min(current + 50, 1000);
    });

    decrementNodesButton.addEventListener('click', () => {
        const current = parseInt(baseNodesInput.value, 10);
        baseNodesInput.value = Math.max(current - 50, 1);
    });

    // Submit button handler
    submitButton.addEventListener('click', async () => {
        const count = parseInt(countInput.value, 10);
        const baseNodes = parseInt(baseNodesInput.value, 10);
        
        if (count < 1 || count > 10 || isNaN(count)) {
            alert('Please enter a valid count between 1 and 10.');
            return;
        }
        
        if (baseNodes < 1 || baseNodes > 1000 || isNaN(baseNodes)) {
            alert('Please enter a valid base node count between 1 and 1000.');
            return;
        }
        
        submitButton.disabled = true;
        submitButton.textContent = 'Submitting...';
        
        try {
            const response = await fetch('/mock_submit', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    count,
                    base_nodes: baseNodes,
                }),
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            submitButton.textContent = 'Success!';
            setTimeout(() => {
                submitButton.disabled = false;
                submitButton.textContent = 'Submit';
            }, 1000);
        } catch (error) {
            console.error('Error submitting mock simulations:', error);
            submitButton.textContent = 'Error!';
            setTimeout(() => {
                submitButton.disabled = false;
                submitButton.textContent = 'Submit';
            }, 1000);
        }
    });

    // Format a queue item for display
    function formatQueueItem(item) {
        return `
            <div class="bg-gray-800 dark:bg-gray-800 shadow-lg rounded-lg p-4">
                <h3 class="font-medium text-white">${item.params.chart} (${item.params.node_count} nodes, ${item.params.duration_mins} min)</h3>
                <p class="text-gray-300">Predicted Cost: CPU: <span class="font-semibold">${item.predicted_cost.cpu_cores.toFixed(2)}</span> cores | Mem: <span class="font-semibold">${item.predicted_cost.memory_gb.toFixed(2)}</span> GB</p>
                <p class="text-gray-400 text-xs mt-1">ID: ${item.request_id}</p>
            </div>
        `;
    }

    // Format an active item for display
    function formatActiveItem(item) {
        return `
            <div class="bg-gray-800 dark:bg-gray-800 shadow-lg rounded-lg p-4">
                <h3 class="font-medium text-white">${item.params.chart} (${item.params.node_count} nodes, ${item.params.duration_mins} min)</h3>
                <p class="text-gray-300">Actual Cost: CPU: <span class="font-semibold">${item.actual_cost.cpu_cores.toFixed(2)}</span> cores | Mem: <span class="font-semibold">${item.actual_cost.memory_gb.toFixed(2)}</span> GB</p>
                <p class="text-gray-400 text-xs">Predicted: ${item.predicted_cost.cpu_cores.toFixed(2)} / ${item.predicted_cost.memory_gb.toFixed(2)}</p>
                <p class="text-gray-400 text-xs mt-1">ID: ${item.simulation_id}</p>
            </div>
        `;
    }

    // Format the last finished simulation for display
    function formatLastFinishedItem(item) {
        // Format the timestamp
        const finishedDate = new Date(item.finished_at);
        const formattedDate = finishedDate.toLocaleString();
        
        return `
            <div class="bg-gray-800 dark:bg-gray-800 shadow-lg rounded-lg p-4">
                <h3 class="font-medium text-white">${item.params.chart} (${item.params.node_count} nodes, ${item.params.duration_mins} min)</h3>
                <p class="text-gray-300">Final Cost: CPU: <span class="font-semibold">${item.actual_cost.cpu_cores.toFixed(2)}</span> cores | Mem: <span class="font-semibold">${item.actual_cost.memory_gb.toFixed(2)}</span> GB</p>
                <p class="text-gray-400 text-xs">Predicted: ${item.predicted_cost.cpu_cores.toFixed(2)} / ${item.predicted_cost.memory_gb.toFixed(2)}</p>
                <p class="text-gray-300 text-sm mt-2">Completed: ${formattedDate}</p>
                <p class="text-gray-400 text-xs mt-1">ID: ${item.simulation_id}</p>
            </div>
        `;
    }

    // Update the cluster utilization display
    function updateUtilization(utilization) {
        // Update CPU usage
        const cpuPercent = utilization.cpu_percent.toFixed(1);
        cpuProgress.style.width = `${cpuPercent}%`;
        cpuText.textContent = `${utilization.used_cpu_cores.toFixed(1)} / ${utilization.total_cpu_cores.toFixed(1)} cores (${cpuPercent}%)`;
        
        // Update memory usage
        const memPercent = utilization.memory_percent.toFixed(1);
        memoryProgress.style.width = `${memPercent}%`;
        memoryText.textContent = `${utilization.used_memory_gb.toFixed(1)} / ${utilization.total_memory_gb.toFixed(1)} GB (${memPercent}%)`;
        
        // Add color coding based on utilization
        if (utilization.cpu_percent > 80) {
            cpuProgress.classList.remove('bg-blue-600', 'bg-yellow-500', 'bg-blue-400');
            cpuProgress.classList.add('bg-red-600');
        } else if (utilization.cpu_percent > 50) {
            cpuProgress.classList.remove('bg-blue-600', 'bg-red-600', 'bg-blue-400');
            cpuProgress.classList.add('bg-yellow-500');
        } else {
            cpuProgress.classList.remove('bg-yellow-500', 'bg-red-600', 'bg-blue-600');
            cpuProgress.classList.add('bg-blue-400');
        }
        
        if (utilization.memory_percent > 80) {
            memoryProgress.classList.remove('bg-purple-600', 'bg-yellow-500', 'bg-purple-400');
            memoryProgress.classList.add('bg-red-600');
        } else if (utilization.memory_percent > 50) {
            memoryProgress.classList.remove('bg-purple-600', 'bg-red-600', 'bg-purple-400');
            memoryProgress.classList.add('bg-yellow-500');
        } else {
            memoryProgress.classList.remove('bg-yellow-500', 'bg-red-600', 'bg-purple-600');
            memoryProgress.classList.add('bg-purple-400');
        }
    }

    // Setup EventSource for server-sent events
    const evtSource = new EventSource("/status-stream");
    
    evtSource.onopen = () => {
        console.log("SSE connection established");
    };
    
    evtSource.onerror = (error) => {
        console.error("SSE connection error:", error);
    };
    
    evtSource.addEventListener("message", (event) => {
        const data = JSON.parse(event.data);
        console.log("SSE message received:", data);
        
        // Handle different event types
        if (data.type === "QueueUpdated") {
            // Update queue display
            const queueItems = data.data;
            queueContainer.innerHTML = queueItems.length === 0 
                ? '<div class="bg-gray-800 dark:bg-gray-800 shadow-lg rounded-lg p-4 text-gray-300">No simulations in queue</div>' 
                : queueItems.map(formatQueueItem).join('');
        } else if (data.type === "ActiveUpdated") {
            // Update active simulations display
            const activeItems = data.data;
            activeContainer.innerHTML = activeItems.length === 0 
                ? '<div class="bg-gray-800 dark:bg-gray-800 shadow-lg rounded-lg p-4 text-gray-300">No active simulations</div>' 
                : activeItems.map(formatActiveItem).join('');
        } else if (data.type === "LastFinished") {
            // Update last finished simulation display
            const lastFinished = data.data;
            noFinishedElement.style.display = 'none';
            const lastFinishedHTML = formatLastFinishedItem(lastFinished);
            
            // Check if there's already a finished simulation displayed
            const existingFinished = lastFinishedContainer.querySelector('div:not(#no-finished)');
            if (existingFinished) {
                existingFinished.outerHTML = lastFinishedHTML;
            } else {
                lastFinishedContainer.innerHTML = lastFinishedHTML;
            }
        } else if (data.type === "ClusterUtilizationUpdated") {
            // Update cluster utilization display
            updateUtilization(data.data);
        }
    });
</script>
{% endblock %} 